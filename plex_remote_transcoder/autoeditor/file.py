"""Autoeditor for adding / modifying autogenerated lines to configuration files."""
import logging
import os
import shutil
import tempfile
from typing import Generator
from typing import List
from typing import Optional

from .exceptions import MarkerAlreadyExistsError
from .exceptions import MarkerNotFoundError

log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


# ----------------------------------------------------------------------------------------------------------------------
class File(object):
    """Class for operating on markers in a file. The marker includes a start and end line with a matching ID."""

    # ------------------------------------------------------------------------------------------------------------------
    def __init__(self, fileName: str, commentCharacters: Optional[str] = "#", markerLabel: Optional[str] = "AutoEditor"):
        """Initalized the File object.

        Args:
            fileName (str): The file name to use.
            markerName (str): The marker name to use.
            commentCharacters (str): The characters to use as comments deliminters for the file.
            markerLabel (str): The label to use in the marker comment.
        """
        self._fileName = fileName
        self._commentCharacters = commentCharacters
        self._markerLabel = markerLabel

        self._markerLine = commentCharacters + " "
        self._markerLine += "### {} ID-{}: Auto-generated by " + self._markerLabel + " ###"

    # ------------------------------------------------------------------------------------------------------------------
    def _linesFromFile(self) -> Generator[str, None, None]:
        with open(self.fileName, 'rt') as fileLines:
            yield from fileLines

    # ------------------------------------------------------------------------------------------------------------------
    def _isStartMarkerLine(self, line, markerId):
        return line.startswith(self._markerLine.format("BEGIN", markerId))

    # ------------------------------------------------------------------------------------------------------------------
    def _isEndMarkerLine(self, line, markerId):
        return line.startswith(self._markerLine.format("END", markerId))

    # ------------------------------------------------------------------------------------------------------------------
    def _isMarkerLine(self, line, markerId):
        return self._isStartMarkerLine(line, markerId) or self._isEndMarkerLine(line, markerId)

    # ------------------------------------------------------------------------------------------------------------------
    def _advancePastStartMarker(self, lines, markerId):
        for line in lines:
            if self._isStartMarkerLine(line, markerId):
                break
        else:
            raise MarkerNotFoundError(self.fileName, markerId)

    # ------------------------------------------------------------------------------------------------------------------
    def _advanceToEndMarker(self, lines, markerId):
        for line in lines:
            if self._isEndMarkerLine(line, markerId):
                break
        else:
            raise MarkerNotFoundError(self.fileName, markerId)

    # ------------------------------------------------------------------------------------------------------------------
    def _getLinesBeforeEndMarker(self, lines, markerId):
        contents = []
        for line in lines:
            if self._isEndMarkerLine(line, markerId):
                break
            contents.append(line)
        else:
            raise MarkerNotFoundError(self.fileName, markerId)

        yield from contents

    # ------------------------------------------------------------------------------------------------------------------
    def doesMarkerExist(self, markerId: str) -> bool:
        """Returns true if the marker exists in the file.

        Args:
            markerId (str): The marker to look for
        """
        for line in self._linesFromFile():
            if self._isMarkerLine(line, markerId):
                return True

        return False

    # ------------------------------------------------------------------------------------------------------------------
    def addNewMarker(self, markerId: str, newLines: Optional[List[str]] = None) -> None:
        """Adds a new marker section to the file.

        Args:
            markerId (str): The ID for the new marker
            newLines (List[str]): New lines to add in the marker
        """
        lines = self._linesFromFile()
        iterator = iter(lines)
        for line in iterator:
            if self._isMarkerLine(line, markerId):
                raise MarkerAlreadyExistsError(self.fileName, markerId)

        with open(self.fileName, 'a') as fileLines:
            fileLines.write(self._markerLine.format("BEGIN", markerId) + "\n")
            for line in newLines:
                fileLines.write(line + "\n")
            fileLines.write(self._markerLine.format("END", markerId) + "\n")

    # ------------------------------------------------------------------------------------------------------------------
    def getLinesInMarker(self, markerId: str) -> List[str]:
        """Returns all of the lines in between the start and end marker specified.

        Args:
            markerId (str): The marker to pull lines from.
        """
        lines = self._linesFromFile()
        it = iter(lines)
        self._advancePastStartMarker(it, markerId)
        yield from self._getLinesBeforeEndMarker(it, markerId)

    # ------------------------------------------------------------------------------------------------------------------
    def addOrReplaceLinesInMarker(self, markerId: str, newLines: List[str]) -> None:
        """Adds or replaces lines in a marker.

        Args:
            markerId (str): The marker to replace
            newLines (List[str]): The lines to place in the marker
        """
        if self.doesMarkerExist(markerId):
            self.replaceLinesInMarker(markerId, newLines)
        else:
            self.addNewMarker(markerId, newLines)

    # ------------------------------------------------------------------------------------------------------------------
    def replaceLinesInMarker(self, markerId: str, newLines: List[str]) -> None:
        """Replaces all of the lines in between the start and end marker specified.

        Args:
            markerId (str): The marker to replace
            newLines (List[str]): The lines to place in the marker
        """
        with tempfile.TemporaryDirectory() as tempDir:
            newFileName = os.path.join(tempDir, os.path.basename(self.fileName) + ".new")
            with open(newFileName, 'w') as newFile:
                lines = self._linesFromFile()

                # Using an iterator for the original file so we don't have to track ourselves
                iterator = iter(lines)

                # Copy over lines up to (and including) the start marker
                for line in iterator:
                    newFile.write(line)
                    if self._isStartMarkerLine(line, markerId):
                        break
                else:
                    raise MarkerNotFoundError(self.fileName, markerId)

                # Copy over the new content
                for line in newLines:
                    newFile.write(line + "\n")

                # Advance the iterator until the end marker, then copy it over
                for line in lines:
                    if self._isEndMarkerLine(line, markerId):
                        newFile.write(line)
                        break
                else:
                    raise MarkerNotFoundError(self.fileName, markerId)

                # Copy over any remaining lines in the original file
                for line in lines:
                    newFile.write(line)

            shutil.copyfile(newFileName, self.fileName)

    # ------------------------------------------------------------------------------------------------------------------
    @property
    def fileName(self) -> str:
        """The file being worked with."""
        return self._fileName
